<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script>
    //리터럴({},[],"") 방식의 객체 생성
    // const kim={
    //   //필드
    //   //property
    //   firstName: 'kim',
    //   lastName: 'dong',
    //   //method
    //   getFullName: function(){  //=>함수 금지(this가 상위객체를 의미함)
    //     //this: 현재 소속된 객체데이터를 의미
    //     return `${this.firstName} ${this.lastName}`
    //     //return `${kim.firstName} ${kim.lastName}`
    //   }
    // }
    // console.log(kim.getFullName())
    // const lee={
    //   firstName: 'lee',
    //   lastName: 'na',
    //   getFullName: function(){
    //     return `${this.firstName} ${this.lastName}`    
    //   }
    // }
    // console.log(lee.getFullName())
    //생성자 함수를 이용한 객체 생성
    //java의 클래스와 유사(?)
    //new와 사용하는 생성자함수는 대문자로 지정
    function User(first, last) {
      this.firstName = first //this생략 안됨
      this.lastName = last
      //메모리 비효율적(객체마다 함수객체를 생성함)
      // this.getFullName=function(){  
      //   return `${this.firstName} ${this.lastName}`
      // }
    }
    //메모리 효율적
    //함수객체를 user함수의 prototype에 1번만 생성한다.
    User.prototype.getFullName = function () {
      return `${this.firstName} ${this.lastName}`
    }
    //생성자 함수를 통한 kim인스턴스 생성  
    const kim = new User('kim', 'dong')
    const lee = new User('lee', 'na')
    console.log(kim)
    console.log(lee)
    console.log(kim.getFullName())
    console.log(lee.getFullName());

    //javaScript는 prototype(원형)기반 언어임
    const arr = [1, 2, 3];
    console.log(arr)
    //배열객체의 prototype의 includes메소드 확인
    console.log(arr.includes(4)) //false
    console.log(arr.includes(2)) //true
  </script>
</head>

<body>

</body>

</html>